101a102,104
>     /* do a quick check if we have any expired items in the tail.. */
>     item *search;
>     rel_time_t oldest_live = settings.oldest_live;
103c106
<     item *search = heads[id];
---
>     search = tails[id];
105,107c108,125
<         // try to alloc a new item
<         if ((it = slabs_alloc(ntotal, id)) == NULL) {
<             // need to evict
---
>         if ((search->exptime != 0 && search->exptime < current_time)
>             || (search->time <= oldest_live && oldest_live <= current_time)) {  // dead by flush
>             STATS_LOCK();
>             stats.reclaimed++;
>             STATS_UNLOCK();
>             itemstats[id].reclaimed++;
>             if ((search->it_flags & ITEM_FETCHED) == 0) {
>                 STATS_LOCK();
>                 stats.expired_unfetched++;
>                 STATS_UNLOCK();
>                 itemstats[id].expired_unfetched++;
>             }
>             it = search;
>             slabs_adjust_mem_requested(it->slabs_clsid, ITEM_ntotal(it), ntotal);
>             do_item_unlink_nolock(it, hash(ITEM_key(it), it->nkey, 0));
>             /* Initialize the item block: */
>             it->slabs_clsid = 0;
>         } else if ((it = slabs_alloc(ntotal, id)) == NULL) {
114c132,134
< 
---
>             itemstats[id].evicted_time = current_time - search->time;
>             if (search->exptime != 0)
>                 itemstats[id].evicted_nonzero++;
125d144
<             // adjust the slab and unlink the head
144c163
<         /* If the FIFO is empty or locked, attempt to allocate memory */
---
>         /* If the LRU is empty or locked, attempt to allocate memory */
151a171,183
>         /* Last ditch effort. There was a very rare bug which caused
>          * refcount leaks. We leave this just in case they ever happen again.
>          * We can reasonably assume no item can stay locked for more than
>          * three hours, so if we find one in the tail which is that old,
>          * free it anyway.
>          */
>         if (search != NULL &&
>             search->refcount != 2 &&
>             search->time + TAIL_REPAIR_TIME < current_time) {
>             itemstats[id].tailrepairs++;
>             search->refcount = 1;
>             do_item_unlink_nolock(search, hash(ITEM_key(search), search->nkey, 0));
>         }
210c242
< static void item_link_q(item *it) { /* item is the new tail */
---
> static void item_link_q(item *it) { /* item is the new head */
217c249
<     assert(it != *tail);
---
>     assert(it != *head);
219,223c251,255
<     it->prev = *tail;
<     it->next = 0;
<     if (it->prev) it->prev->next = it;
<     *tail = it;
<     if (*head == 0) *head = it;
---
>     it->prev = 0;
>     it->next = *head;
>     if (it->next) it->next->prev = it;
>     *head = it;
>     if (*tail == 0) *tail = it;
315a348,358
>     if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
>         assert((it->it_flags & ITEM_SLABBED) == 0);
> 
>         mutex_lock(&cache_lock);
>         if ((it->it_flags & ITEM_LINKED) != 0) {
>             item_unlink_q(it);
>             it->time = current_time;
>             item_link_q(it);
>         }
>         mutex_unlock(&cache_lock);
>     }
538c581
< }
---
> }
\ No newline at end of file
